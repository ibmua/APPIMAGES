#!/bin/bash

# AppImage Installer Utility
# Extracts and installs AppImages without requiring sudo
# Usage: ./install-appimage [OPTIONS] <appimage-file> [install-directory]

set -e

# Default values
DEFAULT_INSTALL_DIR="/home/i/Documents"
CREATE_DESKTOP_ENTRY=true
CUSTOM_NAME=""

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Helper functions
print_success() {
    echo -e "${GREEN}✓${NC} $1"
}

print_error() {
    echo -e "${RED}✗${NC} $1"
}

print_info() {
    echo -e "${YELLOW}ℹ${NC} $1"
}

show_help() {
    cat << EOF
Usage: install-appimage [OPTIONS] <appimage-file> [install-directory]

Options:
  -d, --desktop          Create desktop entry (default)
  --no-desktop          Skip desktop entry creation
  -n, --name <name>     Custom application name
  -h, --help            Show this help message

Examples:
  install-appimage LM-Studio-0.4.2-2-x64.AppImage
  install-appimage --no-desktop MyApp.AppImage /opt/apps/
  install-appimage -n "LM Studio Beta" LM-Studio-beta.AppImage

Description:
  This utility extracts AppImages and installs them in a directory structure
  similar to the working lm-studio-317 installation. It handles chrome-sandbox
  permission issues by extracting the AppImage contents, and optionally creates
  desktop entries for easy launching.

EOF
}

# Parse command line arguments
POSITIONAL_ARGS=()
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            exit 0
            ;;
        -d|--desktop)
            CREATE_DESKTOP_ENTRY=true
            shift
            ;;
        --no-desktop)
            CREATE_DESKTOP_ENTRY=false
            shift
            ;;
        -n|--name)
            CUSTOM_NAME="$2"
            shift 2
            ;;
        -*)
            print_error "Unknown option: $1"
            show_help
            exit 1
            ;;
        *)
            POSITIONAL_ARGS+=("$1")
            shift
            ;;
    esac
done

# Restore positional parameters
set -- "${POSITIONAL_ARGS[@]}"

# Validate input
if [[ $# -lt 1 ]]; then
    print_error "Missing required argument: appimage-file"
    show_help
    exit 1
fi

APPIMAGE_FILE="$1"
INSTALL_DIR="${2:-$DEFAULT_INSTALL_DIR}"

# Check if AppImage file exists
if [[ ! -f "$APPIMAGE_FILE" ]]; then
    print_error "AppImage file not found: $APPIMAGE_FILE"
    exit 1
fi

# Get absolute path of AppImage
APPIMAGE_FILE=$(realpath "$APPIMAGE_FILE")

# Extract base name and create installation directory name
APPIMAGE_BASENAME=$(basename "$APPIMAGE_FILE")
# Remove .AppImage extension and clean up version strings
APP_NAME=$(echo "$APPIMAGE_BASENAME" | sed -E 's/\.AppImage$//i' | sed -E 's/[-_]x(86_)?64//i' | tr '[:upper:]' '[:lower:]')

# Create installation directory path
INSTALL_PATH="$INSTALL_DIR/$APP_NAME"

print_info "AppImage: $APPIMAGE_BASENAME"
print_info "Installation directory: $INSTALL_PATH"

# Check if installation directory already exists
if [[ -d "$INSTALL_PATH" ]]; then
    print_info "Installation directory already exists: $INSTALL_PATH"
    read -p "Do you want to overwrite it? [y/N] " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        print_info "Installation cancelled."
        exit 0
    fi
    print_info "Backing up existing installation to $INSTALL_PATH.backup"
    rm -rf "$INSTALL_PATH.backup"
    mv "$INSTALL_PATH" "$INSTALL_PATH.backup"
fi

# Create temporary extraction directory
TEMP_DIR=$(mktemp -d)
trap "rm -rf $TEMP_DIR" EXIT

print_info "Extracting AppImage..."

# Make AppImage executable and extract
chmod +x "$APPIMAGE_FILE"

# Extract in temporary directory
cd "$TEMP_DIR"
"$APPIMAGE_FILE" --appimage-extract > /dev/null 2>&1

if [[ ! -d "squashfs-root" ]]; then
    print_error "Failed to extract AppImage"
    exit 1
fi

print_success "AppImage extracted successfully"

# Move extracted contents to installation directory
print_info "Installing to $INSTALL_PATH..."
mkdir -p "$INSTALL_DIR"
mv squashfs-root "$INSTALL_PATH"

# Make AppRun executable
if [[ -f "$INSTALL_PATH/AppRun" ]]; then
    chmod +x "$INSTALL_PATH/AppRun"
    print_success "AppRun configured"
else
    print_error "Warning: AppRun not found in extracted contents"
fi

# Fix chrome-sandbox permissions if it exists
if [[ -f "$INSTALL_PATH/chrome-sandbox" ]]; then
    print_info "Fixing chrome-sandbox permissions (requires sudo)..."
    if sudo chown root:root "$INSTALL_PATH/chrome-sandbox" && sudo chmod 4755 "$INSTALL_PATH/chrome-sandbox"; then
        print_success "chrome-sandbox permissions configured"
    else
        print_error "Failed to set chrome-sandbox permissions"
        print_info "The application may require --no-sandbox flag to run"
    fi
fi

# Find and process desktop entry
if [[ "$CREATE_DESKTOP_ENTRY" == true ]]; then
    print_info "Creating desktop entry..."

    # Find .desktop file in extracted contents
    DESKTOP_FILE=$(find "$INSTALL_PATH" -maxdepth 1 -name "*.desktop" -type f | head -n 1)

    if [[ -n "$DESKTOP_FILE" ]]; then
        DESKTOP_BASENAME=$(basename "$DESKTOP_FILE")
        DESKTOP_TARGET="$HOME/.local/share/applications/$DESKTOP_BASENAME"

        # Read the desktop file and update paths
        mkdir -p "$HOME/.local/share/applications"

        # Process desktop file
        while IFS= read -r line; do
            if [[ "$line" =~ ^Exec= ]]; then
                # Update Exec path to point to our installation
                EXEC_VALUE=$(echo "$line" | cut -d= -f2-)
                # Replace 'AppRun' or relative paths with absolute path
                EXEC_NEW=$(echo "$EXEC_VALUE" | sed "s|^\./\?AppRun|$INSTALL_PATH/AppRun|" | sed "s|^AppRun|$INSTALL_PATH/AppRun|")
                # Remove --no-sandbox flag since we're fixing chrome-sandbox permissions
                EXEC_NEW=$(echo "$EXEC_NEW" | sed 's/--no-sandbox *//')
                echo "Exec=$EXEC_NEW"
            elif [[ "$line" =~ ^Icon= ]]; then
                # Update Icon path if it's a relative path
                ICON_VALUE=$(echo "$line" | cut -d= -f2-)
                if [[ ! "$ICON_VALUE" =~ ^/ ]]; then
                    # Relative path, make it absolute
                    echo "Icon=$INSTALL_PATH/$ICON_VALUE"
                else
                    echo "$line"
                fi
            elif [[ "$line" =~ ^Name= ]] && [[ -n "$CUSTOM_NAME" ]]; then
                # Use custom name if provided
                echo "Name=$CUSTOM_NAME"
            else
                echo "$line"
            fi
        done < "$DESKTOP_FILE" > "$DESKTOP_TARGET"

        chmod +x "$DESKTOP_TARGET"

        # Update desktop database
        if command -v update-desktop-database &> /dev/null; then
            update-desktop-database "$HOME/.local/share/applications" 2>/dev/null || true
        fi

        print_success "Desktop entry created: $DESKTOP_TARGET"

        # Extract application name from desktop file
        APP_DISPLAY_NAME=$(grep "^Name=" "$DESKTOP_TARGET" | head -n 1 | cut -d= -f2-)
    else
        print_error "Warning: No .desktop file found in AppImage"
        print_info "You can manually create a desktop entry later"
    fi
fi

# Create a version-agnostic symlink
# Extract base app name without version numbers
BASE_APP_NAME=$(echo "$APP_NAME" | sed -E 's/-[0-9]+(\.[0-9]+)*(-[0-9]+)?$//')
if [[ "$BASE_APP_NAME" != "$APP_NAME" ]]; then
    SYMLINK_PATH="$INSTALL_DIR/${BASE_APP_NAME}-latest"
    ln -sfn "$APP_NAME" "$SYMLINK_PATH"
    print_success "Created symlink: $SYMLINK_PATH -> $APP_NAME"
fi

# Installation complete
echo
print_success "Installation complete!"
echo
echo "Installation details:"
echo "  Location: $INSTALL_PATH"
echo "  Launch command: $INSTALL_PATH/AppRun"

if [[ -n "$APP_DISPLAY_NAME" ]] && [[ "$CREATE_DESKTOP_ENTRY" == true ]]; then
    echo "  Desktop entry: $APP_DISPLAY_NAME"
fi

echo
print_info "To update to a newer version, simply run this script again with the new AppImage"
echo "  Example: $0 $APPIMAGE_BASENAME"
echo
